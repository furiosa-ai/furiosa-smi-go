// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package binding

/*
#include "furiosa/furiosa_smi.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *FuriosaSmiObserver) Ref() *C.FuriosaSmiObserver {
	if x == nil {
		return nil
	}
	return (*C.FuriosaSmiObserver)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FuriosaSmiObserver) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFuriosaSmiObserverRef converts the C object reference into a raw struct reference without wrapping.
func NewFuriosaSmiObserverRef(ref unsafe.Pointer) *FuriosaSmiObserver {
	return (*FuriosaSmiObserver)(ref)
}

// NewFuriosaSmiObserver allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFuriosaSmiObserver() *FuriosaSmiObserver {
	return (*FuriosaSmiObserver)(allocFuriosaSmiObserverMemory(1))
}

// allocFuriosaSmiObserverMemory allocates memory for type C.FuriosaSmiObserver in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiObserverMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiObserverValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiObserverValue = unsafe.Sizeof([1]C.FuriosaSmiObserver{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FuriosaSmiObserver) PassRef() *C.FuriosaSmiObserver {
	if x == nil {
		x = (*FuriosaSmiObserver)(allocFuriosaSmiObserverMemory(1))
	}
	return (*C.FuriosaSmiObserver)(unsafe.Pointer(x))
}

// allocFuriosaSmiDeviceHandlesMemory allocates memory for type C.FuriosaSmiDeviceHandles in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceHandlesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceHandlesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceHandlesValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceHandles{})

// allocFuriosaSmiVersionMemory allocates memory for type C.FuriosaSmiVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiVersionValue = unsafe.Sizeof([1]C.FuriosaSmiVersion{})

// allocFuriosaSmiDeviceInfoMemory allocates memory for type C.FuriosaSmiDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceInfoValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceInfo{})

// allocFuriosaSmiDeviceFileMemory allocates memory for type C.FuriosaSmiDeviceFile in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceFileValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceFileValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceFile{})

// allocFuriosaSmiDeviceFilesMemory allocates memory for type C.FuriosaSmiDeviceFiles in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceFilesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceFilesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceFilesValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceFiles{})

// allocA64FuriosaSmiDeviceFileMemory allocates memory for type [64]C.FuriosaSmiDeviceFile in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA64FuriosaSmiDeviceFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA64FuriosaSmiDeviceFileValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA64FuriosaSmiDeviceFileValue = unsafe.Sizeof([1][64]C.FuriosaSmiDeviceFile{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocFuriosaSmiCoreStatusesMemory allocates memory for type C.FuriosaSmiCoreStatuses in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiCoreStatusesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiCoreStatusesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiCoreStatusesValue = unsafe.Sizeof([1]C.FuriosaSmiCoreStatuses{})

// allocFuriosaSmiDeviceErrorInfoMemory allocates memory for type C.FuriosaSmiDeviceErrorInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceErrorInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceErrorInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceErrorInfoValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceErrorInfo{})

// allocFuriosaSmiDriverInfoMemory allocates memory for type C.FuriosaSmiDriverInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDriverInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDriverInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDriverInfoValue = unsafe.Sizeof([1]C.FuriosaSmiDriverInfo{})

// allocA24FuriosaSmiVersionMemory allocates memory for type [24]C.FuriosaSmiVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA24FuriosaSmiVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA24FuriosaSmiVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA24FuriosaSmiVersionValue = unsafe.Sizeof([1][24]C.FuriosaSmiVersion{})

// allocFuriosaSmiPeUtilizationMemory allocates memory for type C.FuriosaSmiPeUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiPeUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiPeUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiPeUtilizationValue = unsafe.Sizeof([1]C.FuriosaSmiPeUtilization{})

// allocFuriosaSmiMemoryUtilizationMemory allocates memory for type C.FuriosaSmiMemoryUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiMemoryUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiMemoryUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiMemoryUtilizationValue = unsafe.Sizeof([1]C.FuriosaSmiMemoryUtilization{})

// allocFuriosaSmiDeviceUtilizationMemory allocates memory for type C.FuriosaSmiDeviceUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceUtilizationValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceUtilization{})

// allocA64FuriosaSmiPeUtilizationMemory allocates memory for type [64]C.FuriosaSmiPeUtilization in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA64FuriosaSmiPeUtilizationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA64FuriosaSmiPeUtilizationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA64FuriosaSmiPeUtilizationValue = unsafe.Sizeof([1][64]C.FuriosaSmiPeUtilization{})

// allocFuriosaSmiDevicePowerConsumptionMemory allocates memory for type C.FuriosaSmiDevicePowerConsumption in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDevicePowerConsumptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDevicePowerConsumptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDevicePowerConsumptionValue = unsafe.Sizeof([1]C.FuriosaSmiDevicePowerConsumption{})

// allocFuriosaSmiDeviceTemperatureMemory allocates memory for type C.FuriosaSmiDeviceTemperature in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFuriosaSmiDeviceTemperatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFuriosaSmiDeviceTemperatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFuriosaSmiDeviceTemperatureValue = unsafe.Sizeof([1]C.FuriosaSmiDeviceTemperature{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}
